"""Autofix helpers for documenting environment variables."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, Iterator, List, Sequence, Set, Tuple

from .rules.env_keys_example import (
    ENV_ASSIGN_RE,
    ENV_CALL_RE,
    ENV_EXAMPLE_PATTERNS,
    IGNORED_ENV,
    SOURCE_PATTERNS,
    load_app_config_keys,
)


@dataclass(frozen=True)
class AutofixEntry:
    """Summary of a single env key that was appended to .env.example."""

    key: str
    target: Path
    references: Tuple[str, ...]


def _iter_paths(root: Path, patterns: Sequence[str]) -> Iterator[Path]:
    seen: Set[Path] = set()
    for pattern in patterns:
        for path in root.glob(pattern):
            if not path.is_file():
                continue
            resolved = path.resolve()
            if resolved in seen:
                continue
            seen.add(resolved)
            yield resolved


def _collect_referenced_keys(root: Path) -> Dict[str, Set[str]]:
    references: Dict[str, Set[str]] = {}
    for path in _iter_paths(root, SOURCE_PATTERNS):
        try:
            text = path.read_text(encoding="utf-8")
        except (UnicodeDecodeError, FileNotFoundError):
            continue
        relative = path.relative_to(root).as_posix()
        for match in ENV_CALL_RE.finditer(text):
            key = match.group(1)
            if key in IGNORED_ENV:
                continue
            references.setdefault(key, set()).add(relative)
    return references


def _collect_documented_keys(root: Path) -> Tuple[Set[str], List[Path]]:
    documented: Set[str] = set()
    candidate_paths: List[Path] = []
    for path in _iter_paths(root, ENV_EXAMPLE_PATTERNS):
        candidate_paths.append(path)
        try:
            text = path.read_text(encoding="utf-8")
        except (UnicodeDecodeError, FileNotFoundError):
            continue
        for key in ENV_ASSIGN_RE.findall(text):
            documented.add(key)
    return documented, candidate_paths


def _select_target(root: Path, candidates: List[Path]) -> Path:
    root_example = root / ".env.example"
    if root_example.exists():
        return root_example.resolve()
    if candidates:
        return candidates[0]
    return root_example.resolve()


def _ensure_file_exists(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    if not path.exists():
        header = "# Generated by diagnostics auto-fix; populate as needed.\n"
        path.write_text(header, encoding="utf-8")


def _format_reference_hint(references: Iterable[str]) -> str:
    ordered = sorted(references)
    if not ordered:
        return "unknown location"
    if len(ordered) == 1:
        return ordered[0]
    preview = ", ".join(ordered[:2])
    remaining = len(ordered) - 2
    if remaining <= 0:
        return preview
    plural = "s" if remaining > 1 else ""
    return f"{preview} + {remaining} more reference{plural}"


def apply_autofix(root: Path) -> List[AutofixEntry]:
    """Append missing environment keys to .env.example with placeholders."""

    references = _collect_referenced_keys(root)
    documented, candidates = _collect_documented_keys(root)
    app_config_keys = load_app_config_keys(root)

    missing = sorted(
        key
        for key, paths in references.items()
        if key not in documented and key not in app_config_keys
    )
    if not missing:
        return []

    target = _select_target(root, candidates)
    _ensure_file_exists(target)

    appended: List[AutofixEntry] = []
    text = target.read_text(encoding="utf-8")
    needs_trailing_newline = not text.endswith("\n")
    with target.open("a", encoding="utf-8") as handle:
        if needs_trailing_newline:
            handle.write("\n")
        for key in missing:
            refs = references.get(key, set())
            hint = _format_reference_hint(refs)
            handle.write(f"# Added by diagnostics auto-fix: referenced in {hint}\n")
            handle.write(f"{key}=changeme\n")
            appended.append(
                AutofixEntry(key=key, target=target, references=tuple(sorted(refs)))
            )
    return appended


__all__ = ["AutofixEntry", "apply_autofix"]
